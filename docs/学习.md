

# 第六章：数据库

## 4、存储过程和函数

### 4.1、存储过程和函数概述

存储过程和函数的区别在于函数必须有返回值，而存储过程没有。

函数：是一个有返回值的过程

过程：是一个没有返回值的函数

### 4.2、创建存储过程







接口

1、查询列表
2、查询详情
3、分享

4、下单

​	4.1、分享提成算法

​	4.2、购买（查询库存和）

​	4.3、优惠券查询	





# 第八章：最新技术

## 一、redis使用

### 1、Redis安装

### 2、Redis核心配置文件Redis.conf讲解文件

### 3、Docker安装Redis

### 4、Redis常用数据类型及应用场景

springboot2.x中Redis进行连接（RedisTemlate【Lettuce代替】）

### 5、其他功能

redis订阅发布

redis事务 --》商品秒杀哦应用场景进行案例展示

redis数据淘汰策略

redis持久化

redis缓存与数据库（Mysql）同步

-->使用的是Kafka作为异步队列

redis知识点总结：

​	缓存穿透、缓存雪崩、热点key等处理方案（会双重锁的使用）

### 6、redis高级配置

redis5版本集群创建

java客户端远程连接RedisCluster实战应用

springboot2.x+redisCluster整合操作















# 一、jvm优化

## 1、为什么要对jvm做优化？

1、运行的应用“卡住了”，日志不输出，程序没有反应

2、服务器的cpu负载突然升高

3、在多线程应用下，如何分配县城的数量



# 第十章、项目业务逻辑问题

## 一、传统项目

### 1、什么是BOS？

**ERP系统**是企业资源计划（enterprise resource planning）的简称。

**BOSS**（business&operation support）：指的是业务运营支撑系统。

BOS是ERP的集成与应用平台。BOS遵循面向服务的结构体系，是一个面向业务的可视化开发平台；是一个ERP和第三方应用集成的技术平台。它有效的解决了ERP应用的最主要矛盾--用户需求个性化和传统ERP软件标准化之间的矛盾。

BOS与ERP是什么关系？

ERP是企业管理信息化的全面解决方案，ERP是基于BOS构建的。ERP满足企业全部业务的标准应用；BOS确保了企业ERP应用中的个性化需求完美实现基于BOS的ERP，可以为不同行业不同发展阶段的企业构建灵活的、可扩展的、全面集成的整体解决方案。

### 2、Activity工作流

#### 2.1什么是工作流？

工作的一个流程，事务发展的一个业务过程。就是通过计算机对业务流程自动化执行管理。

#### 2.2、什么是工作流系统？
对系统的业务流程进行自动化管理，所有工作流是建立在业务流程的基础上，所以一个软件的系统核心根本上还是系统的业务流程，工作流只是协助进行业务流程管理。





# 一、springboot源码（bilibili）











# 3、阶段三第一阶段总结

1、什么是工作流？

2、工作流，工作流系统，BPM（业务流程管理），BPMN（业务流程模型和符号，是一种标准）

3、流程定义：

请假流程：填写请假单--部门经理--总经理--财务经理

4、流程设计器：

Eclipsc/idea安装Activiti Designer

5、测试是否已经安装成功

6、为什么使用activiti可以实现业务代码不变更，皆可以实现流程更新。

流程定义图做更新--》先读取节点信息到数据库表中--》后续就针对数据库表进行操作

7、activiti支持的数据库有哪些？

8、25张表的创建，activiti要能够工作，就必须有表结构的支撑。

9、使用java代码来生成25张表。

​	1、pim.xml文件需要引入activiti开发相关的坐标

​	2、log4j.properties日志文件添加

​	3、activiti.cfg.xml默认配置文件，也可以是其他名称、

​		配置数据源

​		创建ProcessEnginConfiguration对象，使用脱机方式StandaloneProcessEngineConfuguration，databaseSchemaUpdate=true;

​	4、写java代码

​		ProcessEngineConfiguration类

​		ProcessEngine类

















# 第一、面试总结

## 一、学习课程（儒猿技术窝第一季）

### 进度：    21_redis都有哪些数据类型？分别在哪些场景下使用比较合适呢？ 1、消息队列

**遗留问题：**

1、kafka的复制的底层原理

2、leader选举的算法

3、增加partition以后的rebalance算法，

4、如何优化kafka写入的吞吐量



##### 1、应用场景？

 异步处理，应用解耦，流量削锋和消息通讯四个场景 

##### 2、各消息队列的优缺点?

 **ActiveMQ :**万级别，现在维护更新时间长维护少，ms级别，偶尔丢失消息，MQ领域功能极其完备，主从架构，主要用来做解耦和异步，较少大规模的高吞吐。

 **RabbitMQ ：**万级别，微秒级（最大的特点），MQ功能比较完备，开源管理界面很好（后台监控界面），主从架构，erlang语言开发（高并发语言，但是维护成本很贵，只能依赖于开源社区），性能很好，延时很低，国内中小公司常用，开源社区很活跃。

 **RocketMQ ：**10万级别，阿里开源（源码也是java），文档相对于少点，社区活跃度相对还活跃，topic可以达到几百，几千个级别但是吞吐会影响，分布式架构，经过参数优化配置可以做到0丢失数据，MQ功能比较完备，还是分布式。

 **Kafka ：**（Apache）10万级别，ms级别，参数优化也能0丢失，功能比较简单，支持简单的MQ，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准。

##### 3、如何保证消息队列的高可用？

**1、rabbitMQ：**

​	1、单机模式： 
​	2、普通集群模式：

​	3、镜像集群模式：

**rabbitMQ丢失数据：**

​	**1、生产者丢失数据处理方案：**

​		1、消费事务channel.txSelect 的try(){}catch(){channel.txRollback} channel.txCommit（没有直接提交）进行回滚。**问题：**事务回滚处理是同步，生产者发送消息同步阻塞，影响吞吐性能

​		2、你先把channel设置成confirm的模式，（channel.confirm //然后发送消息，不用管了）发送一个之后就不用管了，如果消费者收到消息，就会回调你生产者的一个借口，通知你这个消息已经收到，接受消息失败回调接口，告诉你接受失败了（这个方案吞吐量会高一些）

​	**2、rabbitMQ丢失数据**

​		1、持久化磁盘上去

​			1、创建queue的时候将其设置为持久化，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据。

​			2、queue持久化：

​				1、发送消息的时候将消息deleveryMode设置为2，就是将消息设置为持久化，此时rabbitmq就会将消息持久化到磁盘上去，必须要同时设置这两个持久化才行。rabbitmq如果怪了会从磁盘回复queue没回复这个queue里的数据。{问题：吃几口i加的过程中rabbitmq挂了，就会导致内存里的一点数据会丢失}

​	3、**消费者丢失数据：**

​	1、**原因：**打开了消费者outoAck的机制才会丢失（会自动通知生产者消费完这个消息），如果还在处理中，还没有处理完，这时候自动autoAck，通知生产者已经消费了，以为消费者已经消费掉了。

​	2、**处理方案：**:关闭aotoAck，然后自己手动发送ack给rabbitmq，如过还没有处理完就宕机了，没有回发ack，此时rabbitmq会将这条消息重新分配给其他的消费者去处理

**2、kafka**：分布式多台机器（不同数据）每台机器上面有broker-partition-follower和（broker-partition-leader挂掉的话重新选举）broker-partition-follower同步数据

**1、丢失数据：**唯一可能导致消费者弄丢数据的情况，就是消费者收到消息，就会自动提交sffset，以为已经消费了，然而还没有处理完就挂掉了

​	**处理方案：**关闭自动提交offset，处理完之后手动提交{**问题：**处理完了还没有offset，自己挂了也会导致重复消费问题，保证幂等性就好了}

**2、kafka自己丢失数据**：

​	1、**场景：**broker-partition-leader在和broker-partition-follower同步数据时候还没有同步leader直接挂掉，follower重新选择leader，但是数据还没有同步。

​	2、**解决方案：**设置4个参数：

​		1、要求每个partition必须有至少两个副本

​		2、服务端设置min.insvnc.replicas参数；这个值必须大于1，这个要求一个leader之手感知到有至少一个foller还跟自己保持联系，挂了还有一个follower

​		3、在producer端设置acks=all（意思就是leader和follower的数据同步成功了才返回数据成功了）；这个要求每条数据，必须是写入所有replica之后，才能任务是写成功了

​		4、在producer端设置retries=MAX（很大的值）（意思就是leader和follower的数据没有同步同步返回，否则生产者会重试原数据到新的leader上去），这个是要求一旦写入失败，就无限重试，卡在这里了。

3、生产者会不会丢失数据：如果按照上述的思路设置了acks=all;一定不会丢失，要求是，你的leader接受到消息，所有的folliow都同步到了消息之后，才认为本次写成功了，如果没有满足要求，生产者会自动不断重试，重试无限次



##### 4、如何保证消息不被重复消费（或者保证幂等性）？

解决方案：
 1、关闭spring-kafka的自动提交 

 2.延长session-time-out，权衡max.poll.records减少poll（）中返回的批次的最大大小来解决此问题，//一次从kafka中poll出来的数据条数 

 3.权衡自动提交的时间点，ps最好不要使 用这种方式，无法尽量避免重复 

 4.完美解决的话，只有每次都判断消息是否重复消费过了，不过此方式性能开销比较大，严重影响QPS,根据场景取舍 （每次消费的时候去查一下数据量有没有消费记录）

### 二、lencen/es

**遗留问题：**

1、es底层相关度评分算法（TF/IDF算法）deep paging、上千万数据批处理、跨机房多集群同步、所搜效果优化？

![es-write-detail](/images/es-write-detail.png)



![1595330628568](C:\Users\zhouwei\AppData\Roaming\Typora\typora-user-images\1595330628568.png)

![1595330568436](C:\Users\zhouwei\AppData\Roaming\Typora\typora-user-images\1595330568436.png)

#### 1、es用来存储的基本单位：索引。

es中index -> type -> mapping -> document -> field

es里的写流程，有**四个底层的核心概念**，refresh,flush,translog,merge。

当segement file躲到一定程度的时候，es就会触发merge操作，将多个segment file文件合成一个segment file文件.旧的文件就会被删掉。在merge的时候回看一下.del文件删除的数据，合成的新文件会真正删除掉.del文件的数据。

数据写入segment时候就建立了倒排索引。

**查询**：get某一条数据，写入了某个document，
用es（写入要用来检索的少数字段就可以了）+Hbase（不用来检索的海量数据放在这里面）架构，写入es的数据小于等于与或者略微大于es的filesystem cache的内存容量。

1、**数据预热**：当处理es的数据还是大于es的filesystem cache内存很多，可以采用数据预热，（）

 2、**冷热分离**：es可以做类似于mysql的水平拆分和水平拆分。

3、**document模型设置：**尽量不要复杂关联查询，写入es的时候就直接把关系直接写进去，避免关联查询。
4、**分页性能优化：**不允许深度分页/默认深度分页性能很惨。

如果有类似app；哦的推荐商品不断下拉出来一页一页的：可以用**scrll api（**自己百度）

scroll 会一次性给你生成**所有数据的一个快照**，然后每次滑动向后翻页就是通过**游标** `scroll_id` 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。

举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。

分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你**必须**得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。



### 三、redis





## 二、舒萍给的资料

2020-07-15  周日

##### 1.线程的生命周期状态有哪些?

~~~java
	参考于： java.lang.Thread.State 
​	java线程具有五种基本状态：新建状态（New）-->可运行状态（Runnable）-->阻塞状态（Blocked）--> 等待状	态（Waiting）-->超时等待状态（Time_Waiting）-->终止状态（Terminated）

​	1、新建状态（New）：当线程对象对创建时，即进入了新建状态，如：Thread t = new Thread();线程还未开始
  
​	2、可运行状态（Runnable）：当调用线程对象的start（）方法（t.start()），可运行状态，只是说明此线程已	经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行。
    
​	3、阻塞状态（Blocked）： 在等待一个监视器锁（也就是我们常说的synchronized）或者在调用了				Object.wait()方法且被notify()之后也会进入BLOCKED状态 
    
​	4、等待状态（Waiting ）：等待状态，在调用了以下方法后进入此状态
    	1、Object.wait()无超时的方法后且未被notify()前，如果被notify()了会进入BLOCKED状态
    	2、Thread.join()无超时的方法后
    	3、LockSupport.park()无超时的方法后
    
​	5、超时等待状态（Time_Waiting）：超时等待状态，在调用了以下方法后会进入超时等待状态
      	1、Thread.sleep()方法后
     	2、Object.wait(timeout)方法后且未到超时时间前，如果达到超时了或被notify()了会进入BLOCKED状态
    	3、Thread.join(timeout)方法后
     	4、LockSupport.parkNanos(nanos)方法后
    	5、LockSupport.parkUntil(deadline)方法后
    
​	6、终止状态（Terminated）：线程已经执行完毕
~~~

##### 2.有哪几种方式有创建线程?

1、**继承Thread类：**

​		1、定义Thread类的子类，并重写run()方法

​		2、创建该子类的实力，即创建了线程对象

​		3、调用线程对象start()方法类启动该线程

2、**实现Runnable接口**：

​		1、定义了一个实现Runnable接口的类，并重写run()方法

​		2、创建该类的实例，并将此实例作为Thread的target来创建Thread对象，该Thread对象是真正的线程对象

​		3、调用该线程对象的start()方法启动该线程

3、**通过callable和Future创建对象**

​		1、定义一个实现Call()方法，该call方法将作为线程执行体，并且有返回值

​		2、创建该类的实例，并使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值

​		3、创建FutureTask实例，并将其作为Thread的task创建并启动新线程

​		4、调用FutureTask对象的get()犯法来获得子线程执行结束的返回值。

##### 3.加锁的方式有哪几种?

##### 1.线程的生命周期状态有哪些?

##### 2.有哪几种方式有创建线程?
##### 3.加锁的方式有哪几种?
##### 4.Synchronized与Lock的性能比较如何?
##### 5.线程池有几种分别效果如何?
##### 6.线程池的组成，拒绝策略?
##### 7.不使用Executors等java工具包，自己如何手动创建线程池?
##### 8.ArrayList的扩容机制?
##### 9.HashMap的扩容机制和数据结构?
##### 10.线程安全的Map有哪些?
##### 11.HashMap变成线程安全方法?
##### 12.知道使用过哪些设计模式?
##### 13.单例的写法?
##### 14.单例，懒加载，双重检查（加锁）后，并发获取单例还是会出现问题？是什么问题，因为什么导致的，如何解决？（volatile ）?
##### 15.Volatile关键字的作用与底层实现原理（内存级别阐述）?
##### 16.Redis的数据结构?
##### 17.Redis的数据过期策略?
##### 18.如何仅缓存热点信息到redis?
##### 19.缓存击穿是什么?
##### 20.缓存雪崩是什么?
##### 21.双亲委派模型是什么?
##### 22.微信支付回调可能会出现什么问题?
##### 23.高吞吐使用那种垃圾收集器?
##### 24.Jvm常用的设置参数有哪些?
##### 25.Jvm内存区域中有哪些东西	?
##### 26.什么是AQS?
##### 27.Java运行时内存有哪些?
##### 28.GC分代收集算法有哪些，都是什么样的策略?
##### 29.GC垃圾收集器有哪些？都是什么样的收集算法?
##### 30.垃圾回收算法又哪几种?
##### 31.Java堆中的数据如何进入老年代的?
##### 32.Java堆中如果一个新建的对象大小比新生代的空间大会发生什么?
##### 33.Java堆中的对象在新生代如何计算进入下一代还是进行垃圾回收?
##### 34.Java如何判断堆中的对象是否还存在引用，是否需要清理?
##### 35.Object. Finalize()的作用是什么   ?



Java基础
HashMap原理，1.7与1.8区别，为什么线程不安全？
聊聊线程安全的synchronizedMap原理与Concurrenthashmap原理，区别是什么，Concurrenthashmap中1.7与1.8区别？
深拷贝与浅拷贝区别
Synchronized底层原理
聊聊自旋锁与互斥锁
介绍四种常用线程池
ThreadPoolExecutor线程池的核心参数介绍及工作原理
线程池大小怎么设置？
介绍JVM的类加载机制
介绍JVM的内存模型
常见垃圾回收算法
聊聊你怎么进行JVM调优
Mysql
数据存储原理（主键索引原理）
为什么不用B树，选择B+树？
聊聊覆盖索引
聊聊聚簇索引
Redis
介绍一下redis
redis几种数据结构原理
redis你有哪些使用场景？
布隆过滤器，位图，跳跃表的原理？
redis内存淘汰策略
redis持久化方式
redis用到的集群方案



mybatis原理
持久层框架用的什么,自动化sql的原理
mybatis拦截器玩过吗
spring的前置处理,后置处理知道吗
applicationContext和BeanFactory的区别,以及用的什么设计模式
applicationContext的获取bean能力来自哪里
Springboot的starter怎么玩
aop原理
动态代理有哪些,对应原理
spring的事务管理和事务传播特性
springmvc流程
分布式锁的redis实现,有哪些
redis的数据结构,及对应的数据结构
位图,布隆过滤器,压缩表,跳跃表知道吗,玩过吗
redis发布订阅玩过吗,底层数据结构是什么
索引失效情况
聚簇索引和非聚簇索引的区别
hashmap1.7 到1.8有哪些变化,为什么线程不安全,有哪些改进,
线程安全的hashmap用过吗,什么原理
线程池参数详解,拒绝策略有哪些,jdk提供的有哪些,分别哪些作用
jvm1.7 到 1.8 有什么变化
哪些数据可以作为gc Root
stw详解
方法区在哪,取消了永久代,那以前的永久代数据存哪去了,
垃圾回收算法及执行流程
cap
zk和eureka区别
dubbo玩过吗



## 二、公司面试

### 一、创智和宇

##### 1、分布式锁？你知道的

##### 2、两个list如何去重，讲究效率？Guava类

##### 3、抽象类和接口的区别？

##### 4、springmvc的流程？（版本：4.3.13）

源码执行流程：

~~~ java
1、dispatchservlet类调用doDispatch(HttpServletRequest request, HttpServletResponse response)

2、getHandler(processedRequest)返回一个HandlerExecutionChain[处理器]实现就在dispatchservlet类

3、调用dispatchservlet里面的getHandlerAdapter(mappedHandler.getHandler()),参数是根据HandlerExecutionChain调用的getHandler，返回一个HandlerAdapter

4、HandlerExecutionChain调用applyPreHandle(processedRequest, response)返回ture或者false，实现类HandlerExecutionChain执行拦截器preHandler()方法

5、HandlerAdapter调用handle（）得到ModelAndView

6、dispatchservlet调用applyPostHandle(processedRequest, response, mv)，实现类HandlerExecutionChain执行拦截器postHandle()方法

7、processDispatchResult调用processDispatchResult()，具体执行render(mv, request, response)渲染view
~~~







##### 5、mysql的优化？（数据库层面和sql层面）读写分离如何保证数据库数据同步？

##### 6、简单介绍一下你之前的项目？

##### 7、你熟悉的设计模式有哪些？

##### 8、get请求时候前后台编码格式不一致如何去改变编码格式？

##### 9、dubbo分布式介绍，注册中心不是zk？

##### 10、mysql事务性？

1、**原子性**：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。

2、**一致性**：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态，如果数据库系统运行中发生故障，有些事务上午

3、**持久性**：也称永久性，指一个事务一旦提交，他对数据库中的数据的改变就应该是永久性的，接下来的其它操作或故障不应该对其执行结果有任何影响。

4、**隔离性**：

​	1、**读未提交：**

​	2、**读提交：**

​	3、**可重复读：**

​	4、**串行化：**

### 二、深圳乐刷

##### 1、介绍一下自己？

##### 1、gataway和zull的区别？优势在哪？

##### 2、springclou各个组件的使用？

##### 3、数据库高并发的场景及使用架构？

##### 4、springcloud gataway 网络编程？

##### 5、spring的bean加载过程，AOP及IOC?

##### 6、springmvc的加载过程？

##### 7、redis使用的架构及为什么能高并发？

